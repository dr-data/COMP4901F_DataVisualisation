<!DOCTYPE html>
<html>
<meta charset="utf-8">
<style>

div.tooltip {	
    position: absolute;			
    text-align: left;			
    width: 100px;					
    height: 45px;					
    padding: 2px;				
    font: 12px sans-serif;		
    background: lightsteelblue;	
    border: 0px;		
    border-radius: 8px;			
    pointer-events: none;			
}

</style>
<body>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<!-- // <script src="d3.js"></script> -->
	<script src="http://d3js.org/topojson.v0.min.js"></script>

	<script>

	function exist(array, data){
		for( i = 0; i < array.length; i++){
			if(data == array[i]){
				return true;
			}
		}
		return false;
	}

	// Get a subset of the data based on the group
	function getFilteredData_Constructor(data, ConstructorName) {
		return data.filter(function(d) { return d.ConstructorName === ConstructorName; });
	}

	function getFilteredData_Year(data, StartYear, EndYear) {
		return data.filter(function(d) { 
			var status = false;
			_tempYearArray = d.Years.split(",");
			// console.log(_tempYearArray);
			// console.log(_tempYearArray.length);
			for(i = 1; i < _tempYearArray.length; i++){
				if((parseInt(_tempYearArray[i]) >= parseInt(StartYear)) && (parseInt(_tempYearArray[i]) <= parseInt(EndYear)))
					status = true;
					break; 
				}
			return status;
			});
	}

	function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
	  var angleInRadians = (angleInDegrees-90) * Math.PI / 180.0;

	  return {
	    x: centerX + (radius * Math.cos(angleInRadians)),
	    y: centerY + (radius * Math.sin(angleInRadians))
	  };
	}

	function describeArc(x, y, radius, startAngle, endAngle){

    var start = polarToCartesian(x, y, radius, endAngle);
    var end = polarToCartesian(x, y, radius, startAngle);

    var largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

    var d = [
        "M", start.x, start.y, 
        "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y
    ].join(" ");

    return d;       
}


	const WIDTH = 500;
	const HEIGHT = 500;

	var margin ={top: 20, right: 20, bottom: 20, left: 20},
		width = WIDTH -margin.left - margin.right,
		height = HEIGHT - margin.top - margin.bottom;

	var radius = d3.scale.linear()
					.range([0, width/4]);

	var color = d3.scale.linear()
					.range(["red", "blue"]);

	function generateRandomRadian(){
		var min = -Math.PI, max = Math.PI;
		var saved_y_radian = Math.random() * 2 * Math.PI;//(max - min) + min;
		return saved_y_radian;
	}

	function generateRandomRadianRestrict(start, end){
		var min = start, max = end;
		var saved_y_radian = Math.random() *(max - min) + min;
		return saved_y_radian;
	}

	var svg = d3.select("body")
				.append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom);

	// Define the div for the tooltip
	var div = d3.select("body").append("div")	
	    .attr("class", "tooltip")				
	    .style("opacity", 0)
	    .style("font", "10px times");

	d3.csv("viz_1.csv", function(data){
		// console.log(error);
		// console.log(data);
		ConstructorNameArray = []
		YearsArray = []
		// Turn data to usable format
		data.forEach(function(d){
			// console.log(d);
			d.raceId = +d.raceId;
			d.driverId= +d.driverId;
			d.startingPosition = +d.startingPosition;
			d.driverStandingsId = +d.driverStandingsId;
			d.points = +d.points;
			d.position = +d.position;
			d.positionText = +d.positionText;
			d.wins = +d.wins;
			d.first_lap_ranks = +d.first_lap_ranks;
			d.first_lap_change = +d.first_lap_change;
			d.accident = +d.accident;

			if(exist(ConstructorNameArray, d.ConstructorName)){
				
			}else{
				ConstructorNameArray.push(d.ConstructorName);
			}
		});

	

	});

	</script>
</body>
</html>